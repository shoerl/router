#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math


# Input: String (st)
# Output: Array of ints
# Split string by period and turn each portion into int,
# then return that int array
def split_by_period_and_get_int_array(st):
    return [int(x) for x in st.split(".")]

# Input: String (st) representing a address/mask. Example: '255.255.255.0'
# Output: Count of non-zero bits
# Return count of non-zero bits in the binary representation of our address/mask
def get_count_of_non_zero_bits(addr):
    count = 0
    int_array = split_by_period_and_get_int_array(addr)
    for num in int_array:
        count += bin(num).count("1")
    return count

def split_by_period_and_get_bin_array(st):
    arr = split_by_period_and_get_int_array(st)
    return list(map(lambda x: '{:08b}'.format(x), arr))

# input: array of strings representing binary (ex: ['1111', '1110'])
# output: tuple representing index of last 1 (ex: (1, 2))
def get_idx_of_last_one(bin_array):
    last_idx = (-1, -1)
    for idx, arr in enumerate(bin_array):
        for idx2, ch in enumerate(arr):
            if ch == '0':
                return last_idx
            else:
                last_idx = (idx, idx2)

# input:  to_search which is string representing address/mask to find last one in Example: '255.255.255.0'
#         to_flip which is string representing adddress/mask to flip bit in position of last one in to_search
# output: String representing to_flip address/mask with flipped bit
# Example: to_search = '255.255.255.0', to_flip = '255.255.0.0', return '255.255.1.0'
def flip_last_one(to_search, to_flip):
    to_search_bin = split_by_period_and_get_bin_array(to_search)
    to_flip_bin = split_by_period_and_get_bin_array(to_flip)

    idx1, idx2 = get_idx_of_last_one(to_search_bin)
    # Turn string into array of characters so we can modify it easily
    to_flip_bin[idx1] = list(to_flip_bin[idx1])
    to_flip_bin[idx1][idx2] = '1' if to_flip_bin[idx1][idx2] == '0' else '0'
    to_flip_bin[idx1] = "".join(to_flip_bin[idx1])

    to_flip_int = list(map(lambda x: int(x, 2), to_flip_bin))
    return "%d.%d.%d.%d" % (to_flip_int[0], to_flip_int[1], to_flip_int[2], to_flip_int[3])


# Input: Two dictionarys, and a list of strings/keys
# Output: Boolean (True/False), representing whether all of those properties are same in these two dictionarys
def dict_all_properties_same(entry1, entry2, keys):
    return all(list(map(lambda key: entry1[key] == entry2[key], keys)))

class Router:

    relations = {}
    sockets = {}
    ports = {}
    forwarding_table = []
    update_cache = []
    withdrawal_cache = []

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def send_update_messages(self, srcif, deserialized_update_msg):
        # if true, we must have gotten from peer or provider, so only send updates to customers
        only_customers = self.relations[srcif] != 'cust'
        update_msg = {'msg': {}, 'type': 'update'}
        update_msg['msg']['netmask'] = deserialized_update_msg['netmask']
        update_msg['msg']['ASPath'] = [self.asn] + deserialized_update_msg['ASPath']
        update_msg['msg']['network'] = deserialized_update_msg['network']
        for network in self.sockets.keys():
            if network == srcif or (only_customers and self.relations[network] != 'cust'):
                continue
            update_msg['src'] = self.our_addr(network)
            update_msg['dst'] = network
            self.send(network, json.dumps(update_msg))

    def send_withdraw_message(self, srcif, withdraw_msg):
        # if true, we must have gotten from peer or provider, so only send updates to customers
        only_customers = self.relations[srcif] != 'cust'
        withdraw_msg = {'msg': withdraw_msg, 'type': 'withdraw'}
        for network in self.sockets.keys():
            if network == srcif or (only_customers and self.relations[network] != 'cust'):
                continue
            withdraw_msg['src'] = self.our_addr(network)
            withdraw_msg['dst'] = network
            self.send(network, json.dumps(withdraw_msg))


    # full deserialized update msg being the full msg (with src, dest, etc..)
    def add_to_update_cache(self, full_deserialized_update_msg):
        self.update_cache.append(full_deserialized_update_msg)

    def add_to_withdrawal_cache(self, full_deserialized_withdraw_msg):
        self.withdrawal_cache.append(full_deserialized_withdraw_msg)

    # deserialized update msg here being the inner update msg
    def add_to_forwarding_table(self, next_hop, deserialized_update_msg):
        deserialized_update_msg['peer'] = next_hop
        self.forwarding_table.append(deserialized_update_msg)

    # Inputs: entry1 and entry2 which are dictionarys representing forwarding table entries
    # Output: dictionary representing best forwarding table entry
    # This function has the constraint that entry2 will never be an empty dictionary, but entry1 may be
    # We compare entries using the rules outlined in the project spec
    def compare_entries_and_get_best(self, entry1, entry2):
        if not entry1:
            return entry2
        # Netmask count here represents the number of 1's in the binary representation
        # of the netmask
        entry1_netmask_count = get_count_of_non_zero_bits(entry1['netmask'])
        entry2_netmask_count = get_count_of_non_zero_bits(entry2['netmask'])
        same_prefix_len = entry1_netmask_count == entry2_netmask_count
        same_local_pref = entry1['localpref'] == entry2['localpref']
        same_self_origin = entry1['selfOrigin'] == entry2['selfOrigin']
        same_as_path_len = len(entry1['ASPath']) == len(entry2['ASPath'])
        same_origin = entry1['origin'] == entry2['origin']
        origin_dict = {"IGP": 2, "EGP": 1, "UNK": 0}
        if entry2_netmask_count > entry1_netmask_count:
            return entry2
        elif same_prefix_len and entry2['localpref'] > entry1['localpref']:
            return entry2
        elif same_prefix_len and same_local_pref and entry2['selfOrigin'] and not entry1['selfOrigin']:
            return entry2
        elif same_prefix_len and same_local_pref and same_self_origin and len(entry2['ASPath']) < len(entry1['ASPath']):
            return entry2
        elif same_prefix_len and same_local_pref and same_self_origin and same_as_path_len and origin_dict[entry2['origin']] > origin_dict[entry1['origin']]:
            return entry2
        elif same_prefix_len and same_local_pref and same_self_origin and same_as_path_len and same_origin and entry2['peer'] < entry1['peer']:
            return entry2
        else:
            return entry1

    # Given destination ip, find best entry in our route cache table
    # TODO: Put in extra logic for breaking ties and stuff
    def find_best_match(self, dst_if):
        best_entry_so_far = {}
        for entry in self.forwarding_table:
            msk_int = split_by_period_and_get_int_array(entry['netmask'])
            dst_int = split_by_period_and_get_int_array(dst_if)
            ntwrk_int = split_by_period_and_get_int_array(entry['network'])
            match = True

            for i in range(len(msk_int)):
                if ntwrk_int[i] != (msk_int[i] & dst_int[i]):
                    match = False

            if not match:
                # Fail fast, also to remove nesting for all of the comparision
                # checking that needs to be done
                continue

            best_entry_so_far = self.compare_entries_and_get_best(best_entry_so_far, entry)

        if best_entry_so_far:
            return best_entry_so_far['peer']
        else:
            return ""       


    def send_data_message(self, deserialized_data_msg, srcif):
        ip_to_send_to = self.find_best_match(deserialized_data_msg['dst'])
        # Is our src or destination a customer?
        src_or_dest_customer = self.relations[srcif] == "cust" or self.relations[ip_to_send_to] == "cust"
        if src_or_dest_customer and ip_to_send_to:
            self.send(ip_to_send_to, json.dumps(deserialized_data_msg))
        else:
            no_route_msg = {'src': self.our_addr(srcif),
                            'dst': deserialized_data_msg['src'],
                            'type': 'no route',
                            'msg': {}}
            self.send(srcif, json.dumps(no_route_msg))
            # send message saying theres no match


    def send_dump_message(self, src, dst):
        self.send(dst,
                  json.dumps({'src': src,
                              'dst': dst,
                              'type': 'table', 
                              'msg': self.forwarding_table}))


    def rebuild_forwarding_table_from_scratch(self):
        self.forwarding_table.clear()
        for entry in self.update_cache:
            self.add_to_forwarding_table(entry['src'], entry['msg'])
        for entry in self.withdrawal_cache:
            self.remove_from_forwarding_table(entry['src'], entry['msg'])
        # loop aggregation incase we need to aggregate more than one entry
        self.loop_aggregation()


    def remove_from_forwarding_table(self, srcif, networks):
        rebuild_and_retry = False
        for network_entry in networks:
            before_len = len(self.forwarding_table)
            self.forwarding_table = list(filter(lambda entry: (not (dict_all_properties_same(entry, network_entry, ['network', 'netmask']) and entry['peer'] == srcif)), self.forwarding_table))
            if before_len == len(self.forwarding_table):
                # We are going to have to rebuild everything, so break out of this loop/function after we are done
                # as the forwarding table will be different + we will handle removing entries seperately there too
                # so we don't want to remove anything twice
                self.rebuild_forwarding_table_from_scratch()
                break

    def get_neighboring_entry(self, network, netmask):
        return flip_last_one(netmask, network)

    # Input: N/A (except self)
    # Output: Pair of entries we can aggregate, empty array if there are no entries to aggregate
    def get_entry_pair_to_aggregate(self):
        for entry in self.forwarding_table:
            neighbor_ntwk = self.get_neighboring_entry(entry['network'], entry['netmask'])
            for entry2 in self.forwarding_table:
                if entry == entry2:
                    continue
                if not dict_all_properties_same(entry, entry2, ['localpref', 'ASPath', 'origin', 'selfOrigin', 'peer']):
                    continue
                if neighbor_ntwk == entry2['network'] and entry['netmask'] == entry2['netmask']:
                    return [entry, entry2]
        return []

    # Helper function for handling rebuilding table, keep aggregating until aggregating
    # produces table of same size
    def loop_aggregation(self):
        old_len = len(self.forwarding_table)
        self.aggregate()
        if len(self.forwarding_table) != old_len:
            self.loop_aggregation()

    def aggregate(self):
        entries = self.get_entry_pair_to_aggregate()
        if not entries:
            return

        if entries[0]['network'] < entries[1]['network']:
            new_entry = entries[0].copy()
        else:
            new_entry = entries[1].copy()

        new_entry['netmask'] = flip_last_one(new_entry['netmask'], new_entry['netmask'])

        self.forwarding_table.remove(entries[0])
        self.forwarding_table.remove(entries[1])
        self.forwarding_table.append(new_entry)

                    

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')

                print("Received message '%s' from %s" % (msg, srcif))
                msg_json = json.loads(msg)
                type = msg_json['type']
                if type == 'update':
                    self.add_to_update_cache(msg_json)
                    self.add_to_forwarding_table(srcif, msg_json['msg'])
                    self.send_update_messages(srcif, msg_json['msg'])
                    self.aggregate()
                elif type == 'data':
                    self.send_data_message(msg_json, srcif)
                elif type == 'dump':
                    self.send_dump_message(msg_json['dst'], msg_json['src'])
                elif type == 'withdraw':
                    self.add_to_withdrawal_cache(msg_json)
                    self.remove_from_forwarding_table(srcif, msg_json['msg'])
                    self.send_withdraw_message(srcif, msg_json['msg'])

                

        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
